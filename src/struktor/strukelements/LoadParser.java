
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sat Feb 10 15:22:38 CET 2007
//----------------------------------------------------

package struktor.strukelements;

import java_cup.runtime.*;
import java.io.*;
import struktor.processor.*;
import java.util.*;
import struktor.processor.datatypes.*;
import struktor.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sat Feb 10 15:22:38 CET 2007
  */
public class LoadParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public LoadParser() {super();}

  /** Constructor which sets the default scanner. */
  public LoadParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public LoadParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\074\000\002\002\003\000\002\002\004\000\002\002" +
    "\004\000\002\003\006\000\002\032\002\000\002\004\005" +
    "\000\002\033\002\000\002\004\006\000\002\005\006\000" +
    "\002\005\005\000\002\006\003\000\002\006\005\000\002" +
    "\007\005\000\002\007\006\000\002\007\004\000\002\007" +
    "\005\000\002\031\005\000\002\034\002\000\002\011\005" +
    "\000\002\035\002\000\002\011\006\000\002\010\004\000" +
    "\002\010\003\000\002\012\004\000\002\012\004\000\002" +
    "\012\004\000\002\013\005\000\002\013\004\000\002\013" +
    "\003\000\002\014\003\000\002\014\004\000\002\015\003" +
    "\000\002\015\003\000\002\015\003\000\002\015\003\000" +
    "\002\015\003\000\002\015\003\000\002\016\004\000\002" +
    "\016\004\000\002\016\003\000\002\016\003\000\002\016" +
    "\003\000\002\017\003\000\002\017\003\000\002\021\007" +
    "\000\002\020\005\000\002\022\005\000\002\022\005\000" +
    "\002\023\007\000\002\024\005\000\002\030\010\000\002" +
    "\027\005\000\002\027\006\000\002\025\003\000\002\025" +
    "\004\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\026\003\000\002\026\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\150\000\004\034\005\001\002\000\006\002\001\034" +
    "\001\001\002\000\004\032\011\001\002\000\006\002\010" +
    "\034\005\001\002\000\006\002\uffff\034\uffff\001\002\000" +
    "\004\002\000\001\002\000\006\012\ufffd\037\ufffb\001\002" +
    "\000\004\006\014\001\002\000\004\014\142\001\002\000" +
    "\030\016\026\020\021\021\031\022\042\023\025\025\043" +
    "\026\016\027\032\030\036\037\037\041\034\001\002\000" +
    "\030\016\026\020\021\021\031\022\042\023\025\025\043" +
    "\026\016\027\032\030\036\037\037\041\034\001\002\000" +
    "\032\007\uffda\016\uffda\017\uffda\020\uffda\021\uffda\022\uffda" +
    "\023\uffda\025\uffda\026\uffda\027\uffda\030\uffda\041\uffda\001" +
    "\002\000\032\007\uffde\016\uffde\017\uffde\020\uffde\021\uffde" +
    "\022\uffde\023\uffde\025\uffde\026\uffde\027\uffde\030\uffde\041" +
    "\uffde\001\002\000\032\007\uffe2\016\uffe2\017\uffe2\020\uffe2" +
    "\021\uffe2\022\uffe2\023\uffe2\025\uffe2\026\uffe2\027\uffe2\030" +
    "\uffe2\041\uffe2\001\002\000\004\031\133\001\002\000\032" +
    "\007\uffdd\016\uffdd\017\uffdd\020\uffdd\021\uffdd\022\uffdd\023" +
    "\uffdd\025\uffdd\026\uffdd\027\uffdd\030\uffdd\041\uffdd\001\002" +
    "\000\006\004\uffeb\013\127\001\002\000\032\007\uffd7\016" +
    "\uffd7\017\uffd7\020\uffd7\021\uffd7\022\uffd7\023\uffd7\025\uffd7" +
    "\026\uffd7\027\uffd7\030\uffd7\041\uffd7\001\002\000\004\031" +
    "\101\001\002\000\004\031\075\001\002\000\032\007\uffd6" +
    "\016\uffd6\017\uffd6\020\uffd6\021\uffd6\022\uffd6\023\uffd6\025" +
    "\uffd6\026\uffd6\027\uffd6\030\uffd6\041\uffd6\001\002\000\004" +
    "\007\074\001\002\000\030\006\047\016\026\020\021\021" +
    "\031\022\042\023\025\025\043\026\016\027\032\030\036" +
    "\041\034\001\002\000\006\025\066\026\067\001\002\000" +
    "\004\004\ufff0\001\002\000\032\007\uffe1\016\uffe1\017\uffe1" +
    "\020\uffe1\021\uffe1\022\uffe1\023\uffe1\025\uffe1\026\uffe1\027" +
    "\uffe1\030\uffe1\041\uffe1\001\002\000\032\007\uffe0\016\uffe0" +
    "\017\uffe0\020\uffe0\021\uffe0\022\uffe0\023\uffe0\025\uffe0\026" +
    "\uffe0\027\uffe0\030\uffe0\041\uffe0\001\002\000\032\007\uffd8" +
    "\016\uffd8\017\uffd8\020\uffd8\021\uffd8\022\uffd8\023\uffd8\025" +
    "\uffd8\026\uffd8\027\uffd8\030\uffd8\041\uffd8\001\002\000\006" +
    "\015\054\033\055\001\002\000\032\007\uffdf\016\uffdf\017" +
    "\uffdf\020\uffdf\021\uffdf\022\uffdf\023\uffdf\025\uffdf\026\uffdf" +
    "\027\uffdf\030\uffdf\041\uffdf\001\002\000\030\007\uffe4\016" +
    "\026\020\021\021\031\022\042\023\025\025\043\026\016" +
    "\027\032\030\036\041\034\001\002\000\004\031\044\001" +
    "\002\000\032\007\uffd9\016\uffd9\017\uffd9\020\uffd9\021\uffd9" +
    "\022\uffd9\023\uffd9\025\uffd9\026\uffd9\027\uffd9\030\uffd9\041" +
    "\uffd9\001\002\000\030\006\047\016\026\020\021\021\031" +
    "\022\042\023\025\025\043\026\016\027\032\030\036\041" +
    "\034\001\002\000\032\007\uffd2\016\uffd2\017\uffd2\020\uffd2" +
    "\021\uffd2\022\uffd2\023\uffd2\025\uffd2\026\uffd2\027\uffd2\030" +
    "\uffd2\041\uffd2\001\002\000\032\007\uffe5\016\uffe5\017\uffe5" +
    "\020\uffe5\021\uffe5\022\uffe5\023\uffe5\025\uffe5\026\uffe5\027" +
    "\uffe5\030\uffe5\041\uffe5\001\002\000\030\007\051\016\026" +
    "\020\021\021\031\022\042\023\025\025\043\026\016\027" +
    "\032\030\036\041\034\001\002\000\004\007\052\001\002" +
    "\000\032\007\uffe6\016\uffe6\017\uffe6\020\uffe6\021\uffe6\022" +
    "\uffe6\023\uffe6\025\uffe6\026\uffe6\027\uffe6\030\uffe6\041\uffe6" +
    "\001\002\000\032\007\uffe7\016\uffe7\017\uffe7\020\uffe7\021" +
    "\uffe7\022\uffe7\023\uffe7\025\uffe7\026\uffe7\027\uffe7\030\uffe7" +
    "\041\uffe7\001\002\000\004\007\uffe3\001\002\000\004\033" +
    "\062\001\002\000\014\004\ufff3\005\ufff3\010\056\012\ufff3" +
    "\013\ufff3\001\002\000\004\040\060\001\002\000\012\004" +
    "\ufff5\005\ufff5\012\ufff5\013\ufff5\001\002\000\004\011\061" +
    "\001\002\000\012\004\ufff1\005\ufff1\012\ufff1\013\ufff1\001" +
    "\002\000\014\004\ufff2\005\ufff2\010\056\012\ufff2\013\ufff2" +
    "\001\002\000\012\004\ufff4\005\ufff4\012\ufff4\013\ufff4\001" +
    "\002\000\004\004\065\001\002\000\030\016\uffef\020\uffef" +
    "\021\uffef\022\uffef\023\uffef\025\uffef\026\uffef\027\uffef\030" +
    "\uffef\037\uffef\041\uffef\001\002\000\032\007\uffdb\016\uffdb" +
    "\017\uffdb\020\uffdb\021\uffdb\022\uffdb\023\uffdb\025\uffdb\026" +
    "\uffdb\027\uffdb\030\uffdb\041\uffdb\001\002\000\032\007\uffdc" +
    "\016\uffdc\017\uffdc\020\uffdc\021\uffdc\022\uffdc\023\uffdc\025" +
    "\uffdc\026\uffdc\027\uffdc\030\uffdc\041\uffdc\001\002\000\004" +
    "\020\071\001\002\000\004\031\072\001\002\000\004\004" +
    "\073\001\002\000\032\007\uffd1\016\uffd1\017\uffd1\020\uffd1" +
    "\021\uffd1\022\uffd1\023\uffd1\025\uffd1\026\uffd1\027\uffd1\030" +
    "\uffd1\041\uffd1\001\002\000\004\014\ufff8\001\002\000\030" +
    "\006\047\016\026\020\021\021\031\022\042\023\025\025" +
    "\043\026\016\027\032\030\036\041\034\001\002\000\032" +
    "\007\uffd4\016\uffd4\017\077\020\uffd4\021\uffd4\022\uffd4\023" +
    "\uffd4\025\uffd4\026\uffd4\027\uffd4\030\uffd4\041\uffd4\001\002" +
    "\000\030\006\047\016\026\020\021\021\031\022\042\023" +
    "\025\025\043\026\016\027\032\030\036\041\034\001\002" +
    "\000\032\007\uffd5\016\uffd5\017\uffd5\020\uffd5\021\uffd5\022" +
    "\uffd5\023\uffd5\025\uffd5\026\uffd5\027\uffd5\030\uffd5\041\uffd5" +
    "\001\002\000\004\006\102\001\002\000\004\036\105\001" +
    "\002\000\032\007\uffd0\016\uffd0\017\uffd0\020\uffd0\021\uffd0" +
    "\022\uffd0\023\uffd0\025\uffd0\026\uffd0\027\uffd0\030\uffd0\041" +
    "\uffd0\001\002\000\006\024\117\036\120\001\002\000\024" +
    "\016\026\020\021\021\031\022\042\023\025\025\043\026" +
    "\016\027\032\030\036\001\002\000\026\016\026\020\021" +
    "\021\031\022\042\023\025\025\043\026\016\027\032\030" +
    "\036\041\uffcc\001\002\000\026\016\uffc7\020\uffc7\021\uffc7" +
    "\022\uffc7\023\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\041" +
    "\uffc7\001\002\000\026\016\uffca\020\uffca\021\uffca\022\uffca" +
    "\023\uffca\025\uffca\026\uffca\027\uffca\030\uffca\041\uffca\001" +
    "\002\000\026\016\uffc6\020\uffc6\021\uffc6\022\uffc6\023\uffc6" +
    "\025\uffc6\026\uffc6\027\uffc6\030\uffc6\041\uffc6\001\002\000" +
    "\004\041\115\001\002\000\026\016\uffc9\020\uffc9\021\uffc9" +
    "\022\uffc9\023\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\041" +
    "\uffc9\001\002\000\026\016\uffc8\020\uffc8\021\uffc8\022\uffc8" +
    "\023\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\041\uffc8\001" +
    "\002\000\006\024\uffce\036\uffce\001\002\000\004\041\uffcb" +
    "\001\002\000\024\016\026\020\021\021\031\022\042\023" +
    "\025\025\043\026\016\027\032\030\036\001\002\000\024" +
    "\016\026\020\021\021\031\022\042\023\025\025\043\026" +
    "\016\027\032\030\036\001\002\000\004\041\122\001\002" +
    "\000\006\024\uffcd\036\uffcd\001\002\000\004\041\124\001" +
    "\002\000\004\007\125\001\002\000\032\007\uffcf\016\uffcf" +
    "\017\uffcf\020\uffcf\021\uffcf\022\uffcf\023\uffcf\025\uffcf\026" +
    "\uffcf\027\uffcf\030\uffcf\041\uffcf\001\002\000\004\004\uffec" +
    "\001\002\000\010\035\131\040\130\042\132\001\002\000" +
    "\004\004\uffea\001\002\000\004\004\uffe8\001\002\000\004" +
    "\004\uffe9\001\002\000\030\006\047\016\026\020\021\021" +
    "\031\022\042\023\025\025\043\026\016\027\032\030\036" +
    "\041\034\001\002\000\032\007\uffd3\016\uffd3\017\uffd3\020" +
    "\uffd3\021\uffd3\022\uffd3\023\uffd3\025\uffd3\026\uffd3\027\uffd3" +
    "\030\uffd3\041\uffd3\001\002\000\004\007\141\001\002\000" +
    "\004\004\uffee\001\002\000\004\004\140\001\002\000\030" +
    "\016\uffed\020\uffed\021\uffed\022\uffed\023\uffed\025\uffed\026" +
    "\uffed\027\uffed\030\uffed\037\uffed\041\uffed\001\002\000\004" +
    "\014\ufff9\001\002\000\006\002\ufffe\034\ufffe\001\002\000" +
    "\004\037\037\001\002\000\004\012\145\001\002\000\004" +
    "\006\ufffc\001\002\000\006\005\150\012\151\001\002\000" +
    "\006\005\ufff7\012\ufff7\001\002\000\004\037\037\001\002" +
    "\000\004\006\ufffa\001\002\000\006\005\ufff6\012\ufff6\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\150\000\006\002\005\003\003\001\001\000\002\001" +
    "\001\000\004\004\011\001\001\000\004\003\006\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\032\143\033" +
    "\142\001\001\000\004\005\012\001\001\000\002\001\001" +
    "\000\032\007\022\010\032\011\014\014\027\015\040\016" +
    "\017\017\034\020\023\021\026\022\037\023\016\024\021" +
    "\001\001\000\030\007\022\010\135\014\134\015\040\016" +
    "\017\017\034\020\023\021\026\022\037\023\016\024\021" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\012\125" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\013\067" +
    "\015\045\016\017\017\034\020\023\021\026\022\037\023" +
    "\016\024\021\001\001\000\002\001\001\000\004\034\063" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\014\052" +
    "\015\040\016\017\017\034\020\023\021\026\022\037\023" +
    "\016\024\021\001\001\000\002\001\001\000\002\001\001" +
    "\000\024\013\044\015\045\016\017\017\034\020\023\021" +
    "\026\022\037\023\016\024\021\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\014\047\015\040\016\017\017" +
    "\034\020\023\021\026\022\037\023\016\024\021\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\031\056\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\031\062\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\013" +
    "\075\015\045\016\017\017\034\020\023\021\026\022\037" +
    "\023\016\024\021\001\001\000\002\001\001\000\024\013" +
    "\077\015\045\016\017\017\034\020\023\021\026\022\037" +
    "\023\016\024\021\001\001\000\002\001\001\000\004\030" +
    "\102\001\001\000\004\027\103\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\016\107\017\112\020\023\021" +
    "\026\022\113\023\106\024\110\025\111\026\105\001\001" +
    "\000\024\016\107\017\112\020\023\021\026\022\113\023" +
    "\106\024\110\025\115\026\105\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\016\107\017\112\020\023\021\026\022" +
    "\113\023\106\024\110\025\122\026\105\001\001\000\024" +
    "\016\107\017\112\020\023\021\026\022\113\023\106\024" +
    "\110\025\120\026\105\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\013\133\015" +
    "\045\016\017\017\034\020\023\021\026\022\037\023\016" +
    "\024\021\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\035\136\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\006\145\007" +
    "\146\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\007\151\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$LoadParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$LoadParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$LoadParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
	// wird benutzt damit auch das die gekapselte Action-Klasse struktor verwenden kann
	action_obj.struktor = this.struktor;

    }


	
	
	Struktor struktor;
	// zweiter Konstruktor
	public LoadParser(java_cup.runtime.Scanner s, Struktor struktor) 
	{	
		this(s);
		this.struktor = struktor;
	}
	
	
	
	public void report_fatal_error(
    String   message,
    Object   info)
    throws java.lang.Exception
    {
      done_parsing();
      report_error(message, info);
      if (message.equals("Can't recover from previous error(s)"))
	    throw new ProcessorException("Undefined Error while loading: "+info);
	  else
	  	throw new ProcessorException("Syntax Error (Loading)!");
    }		 

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$LoadParser$actions {

 

// Struktogramm
Struktogramm struktogramm=null;
// declist
DecList decList;
//struktor
Struktor struktor;


// Kopiert von Constants (weil man im Parser nicht implementen kann)
static public final int COMMAND = 0;
static public final int HEADLOOP = 1;
static public final int TAILLOOP = 2;
static public final int FORLOOP = 3;
static public final int CONDITION = 4;
static public final int SWITCH = 5;
static public final int NEXT = 0;
static public final int INSIDE = 1;
static public final int ALT1 = 2;
static public final int ALT2 = 3;
static public final int ALT = 4;
			   
			   

  private final LoadParser parser;

  /** Constructor */
  CUP$LoadParser$actions(LoadParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$LoadParser$do_action(
    int                        CUP$LoadParser$act_num,
    java_cup.runtime.lr_parser CUP$LoadParser$parser,
    java.util.Stack            CUP$LoadParser$stack,
    int                        CUP$LoadParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$LoadParser$result;

      /* select the action based on the action number */
      switch (CUP$LoadParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // swinstr ::= switchh 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstr",20, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // swinstr ::= tailloop 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstr",20, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // swinstr ::= headloop 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstr",20, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // swinstr ::= condition 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstr",20, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // swinstr ::= command 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstr",20, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // swinstrlist ::= swinstr swinstrlist 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int se2left = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int se2right = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se2 = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					struktogramm.setFirst(se);
					se.connect(COMMAND, se,se2);
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstrlist",19, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // swinstrlist ::= swinstr 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swinstrlist",19, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // caselist ::= caselist CASE swinstrlist BREAK 
            {
              Vector RESULT =null;
		int vectorleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).left;
		int vectorright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).right;
		Vector vector = (Vector)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).value;
		int variableleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		String variable = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		
					vector.addElement(new SwitchValue(se,variable, null));
					RESULT = vector;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("caselist",21, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // caselist ::= CASE swinstrlist BREAK 
            {
              Vector RESULT =null;
		int variableleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int variableright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		String variable = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		
					Vector vector = new Vector();
					vector.addElement(new SwitchValue(se,variable, null));
					RESULT = vector;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("caselist",21, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // swblock ::= LSPAR caselist DEFAULT swinstrlist BREAK RSPAR 
            {
              Vector RESULT =null;
		int vectorleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-4)).left;
		int vectorright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-4)).right;
		Vector vector = (Vector)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-4)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		
					vector.addElement(se);
					RESULT = vector;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("swblock",22, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-5)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // switchh ::= SWITCH CONDITION swblock 
            {
              StrukElement RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int vectorleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int vectorright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Vector vector = (Vector)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					cond = cond.trim();
					Switch switchh = (Switch)struktogramm.addElement(SWITCH,cond);
					for (Enumeration el=vector.elements(); el.hasMoreElements(); )
			    	{
						Object a=el.nextElement();
						// Element ist das Default-Element (wurde der Einfachheit halber einfach mit in den Vector gepackt
						if (a instanceof StrukElement)
						{
							switchh.setDefault((StrukElement)a);
							// mu� nun aber raus !
							vector.removeElement(a);	
						}
						else
						{
							// Der ganze K�se der sonst schon vorher passiert mu� jetzt nachgeholt werden
							((SwitchValue)a).setSwitch(switchh);
							((SwitchValue)a).alt.setUpConnection(switchh,ALT);
						}
			    	} 
					switchh.setAltList(vector);
					RESULT = switchh;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("switchh",18, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // tailloop ::= DO block WHILE CONDITION SEMI 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		
					cond = cond.trim();
					Loop tailLoop = (Loop)struktogramm.addElement(TAILLOOP,cond);
					tailLoop.getInside().delete(true);
					tailLoop.setInside(se);
					RESULT = tailLoop;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("tailloop",17, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-4)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // headloop ::= FOR CONDITION block 
            {
              StrukElement RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// das aufspalten der "condition" ist in der
					// ForLoop gekapselt !
					cond = cond.trim();
					Loop forLoop = (Loop)struktogramm.addElement(FORLOOP,cond);
					forLoop.getInside().delete(true);
					forLoop.setInside(se);
					RESULT = forLoop;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("headloop",16, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // headloop ::= WHILE CONDITION block 
            {
              StrukElement RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					cond = cond.trim();
					Loop headLoop = (Loop)struktogramm.addElement(HEADLOOP,cond);
					headLoop.getInside().delete(true);
					headLoop.setInside(se);
					RESULT = headLoop;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("headloop",16, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ifcond ::= IF CONDITION block 
            {
              StrukElement RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					cond = cond.trim();
					Condition condition = (Condition)struktogramm.addElement(CONDITION,cond);
					condition.getAlt1().delete(true);
					condition.setAlt1(se);
					RESULT = condition;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("ifcond",14, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // ifelsecond ::= IF CONDITION block ELSE block 
            {
              StrukElement RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).right;
		String cond = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int se2left = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int se2right = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se2 = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					cond = cond.trim();
					Condition condition = (Condition)struktogramm.addElement(CONDITION,cond);
					condition.getAlt1().delete(true);
					condition.getAlt2().delete(true);
					condition.setAlt1(se);
					condition.setAlt2(se2);
					RESULT = condition;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("ifelsecond",15, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-4)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // condition ::= ifelsecond 
            {
              StrukElement RESULT =null;
		int conditionleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int conditionright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement condition = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = condition;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("condition",13, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // condition ::= ifcond 
            {
              StrukElement RESULT =null;
		int conditionleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int conditionright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement condition = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = condition;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("condition",13, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // command ::= COMMAND 
            {
              StrukElement RESULT =null;
		int codeleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					code = code.trim();
					Command c = (Command)struktogramm.addElement(COMMAND,code);
					c.setActionType(1);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("command",12, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // command ::= OUTPUT 
            {
              StrukElement RESULT =null;
		int codeleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					code = code.trim();
					Tracer.out("output:"+code);
					Command c = (Command)struktogramm.addElement(COMMAND,code);
					c.setActionType(2);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("command",12, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // command ::= INPUT 
            {
              StrukElement RESULT =null;
		int codeleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					code = code.trim();
					Command c = (Command)struktogramm.addElement(COMMAND,code);
					c.setActionType(0);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("command",12, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // command ::= ADMSG OUTPUT 
            {
              StrukElement RESULT =null;
		int msgleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int msgright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String msg = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int codeleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					msg = msg.trim();
					code = code.trim();
					Command c = (Command)struktogramm.addElement(COMMAND,code);
					c.setActionType(2);
					c.setAdMessage(msg);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("command",12, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // command ::= ADMSG INPUT 
            {
              StrukElement RESULT =null;
		int msgleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int msgright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String msg = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int codeleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					msg = msg.trim();
					code = code.trim();
					Command c = (Command)struktogramm.addElement(COMMAND,code);
					c.setActionType(0);
					c.setAdMessage(msg);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("command",12, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // instr ::= switchh 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // instr ::= tailloop 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // instr ::= headloop 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // instr ::= condition 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // instr ::= BREAK 
            {
              StrukElement RESULT =null;
		int numberleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int numberright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Integer number = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// musste extra implementiert werden weil switch den Break speziell benutzt !
					Command c = (Command)struktogramm.addElement(COMMAND,"break"+(number.intValue()==1 ? ";" : number.toString()));
					c.setActionType(1);
					RESULT = c;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // instr ::= command 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instr",11, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // instrlist ::= instr instrlist 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int se2left = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int se2right = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se2 = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					struktogramm.setFirst(se);
					se.connect(0, se,se2);
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instrlist",10, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // instrlist ::= instr 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("instrlist",10, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // block ::= instr 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("block",9, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // block ::= LSPAR RSPAR 
            {
              StrukElement RESULT =null;
		
					RESULT = struktogramm.addElement(COMMAND);
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("block",9, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // block ::= LSPAR instrlist RSPAR 
            {
              StrukElement RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		StrukElement se = (StrukElement)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		
					RESULT = se;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("block",9, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // assign ::= ASSIGN STRING 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = s;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("assign",8, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // assign ::= ASSIGN DOUBLE 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Double d = (Double)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = d;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("assign",8, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // assign ::= ASSIGN INTEGER 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					RESULT = i;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("assign",8, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // dec ::= parameter 
            {
              Dec RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					dec.setParameter(false);
					RESULT = dec;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("dec",6, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // dec ::= parameter assign 
            {
              Dec RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					dec.setParameter(false);
					dec.setValue(s.toString());
					RESULT = dec;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("dec",6, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // decs ::= decs dec NT$3 SEMI 
            {
              Dec RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Dec) ((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("decs",7, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // NT$3 ::= 
            {
              Dec RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;

					RESULT = dec;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("NT$3",27, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // decs ::= dec NT$2 SEMI 
            {
              Dec RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Dec) ((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("decs",7, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // NT$2 ::= 
            {
              Dec RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Dec dec = (Dec)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;

					RESULT = dec;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("NT$2",26, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // array ::= LEPAR INTEGER REPAR 
            {
              Integer RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		
					if (!struktor.presets.enabArrays)
						throw new StruktorException("Arrays are not allowed !");
					RESULT = i;
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("array",23, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // parameter ::= VARTYPE POINTER VARNAME 
            {
              Dec RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// Wurden nicht erlaubte Datentypen benutzt ?
					if (i.intValue()==Datatype.INTEGER && !struktor.presets.enabInteger)
						throw new StruktorException("Integer not allowed !");
					if (i.intValue()==Datatype.DOUBLE && !struktor.presets.enabDouble)
						throw new StruktorException("Double not allowed !");
					if (i.intValue()==Datatype.CHARACTER && !struktor.presets.enabCharacter)
						throw new StruktorException("Character not allowed !");
					if (i.intValue()==Datatype.STRING && !struktor.presets.enabStrings)
						throw new StruktorException("Strings not allowed !");	
					if (!struktor.presets.enabPointer)
						throw new StruktorException("Pointers are not allowed !");
					RESULT = decList.newDeclaration(true, true, false, 10, i.intValue(), s, "");
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("parameter",5, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // parameter ::= VARTYPE VARNAME 
            {
              Dec RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// Wurden nicht erlaubte Datentypen benutzt ?
					if (i.intValue()==Datatype.INTEGER && !struktor.presets.enabInteger)
						throw new StruktorException("Integer not allowed !");
					if (i.intValue()==Datatype.DOUBLE && !struktor.presets.enabDouble)
						throw new StruktorException("Double not allowed !");
					if (i.intValue()==Datatype.CHARACTER && !struktor.presets.enabCharacter)
						throw new StruktorException("Character not allowed !");
					if (i.intValue()==Datatype.STRING && !struktor.presets.enabStrings)
						throw new StruktorException("Strings not allowed !");	
					RESULT = decList.newDeclaration(false, true, false, 10, i.intValue(), s, "");
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("parameter",5, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // parameter ::= VARTYPE POINTER VARNAME array 
            {
              Dec RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int indizesleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int indizesright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Integer indizes = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// Wurden nicht erlaubte Datentypen benutzt ?
					if (i.intValue()==Datatype.INTEGER && !struktor.presets.enabInteger)
						throw new StruktorException("Integer not allowed !");
					if (i.intValue()==Datatype.DOUBLE && !struktor.presets.enabDouble)
						throw new StruktorException("Double not allowed !");
					if (i.intValue()==Datatype.CHARACTER && !struktor.presets.enabCharacter)
						throw new StruktorException("Character not allowed !");
					if (i.intValue()==Datatype.STRING && !struktor.presets.enabStrings)
						throw new StruktorException("Strings not allowed !");	
					if (!struktor.presets.enabPointer)
						throw new StruktorException("Pointers are not allowed !");
					RESULT = decList.newDeclaration(true, true, true, indizes.intValue(), i.intValue(), s, "");
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("parameter",5, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // parameter ::= VARTYPE VARNAME array 
            {
              Dec RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int indizesleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int indizesright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		Integer indizes = (Integer)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;
		
					// Wurden nicht erlaubte Datentypen benutzt ?
					if (i.intValue()==Datatype.INTEGER && !struktor.presets.enabInteger)
						throw new StruktorException("Integer not allowed !");
					if (i.intValue()==Datatype.DOUBLE && !struktor.presets.enabDouble)
						throw new StruktorException("Double not allowed !");
					if (i.intValue()==Datatype.CHARACTER && !struktor.presets.enabCharacter)
						throw new StruktorException("Character not allowed !");
					if (i.intValue()==Datatype.STRING && !struktor.presets.enabStrings)
						throw new StruktorException("Strings not allowed !");		
					RESULT = decList.newDeclaration(false, true, true, indizes.intValue(), i.intValue(), s, "");
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("parameter",5, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // paramlist ::= paramlist COMMA parameter 
            {
              DecList RESULT =null;
		
					
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("paramlist",4, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // paramlist ::= parameter 
            {
              DecList RESULT =null;
		
					
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("paramlist",4, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // body ::= LSPAR instrlist RSPAR 
            {
              Object RESULT =null;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("body",3, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // body ::= LSPAR decs instrlist RSPAR 
            {
              Object RESULT =null;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("body",3, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // header ::= STRUKNAME NT$1 paramlist RPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)).value;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("header",2, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // NT$1 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;

					struktogramm = struktor.newStruktogramm(s);
					struktogramm.getFirst().delete(true);
					decList = DecList.findDecList(struktogramm);
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("NT$1",25, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // header ::= STRUKNAME NT$0 RPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)).value;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("header",2, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-2)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // NT$0 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$LoadParser$stack.peek()).value;

					struktogramm = struktor.newStruktogramm(s);
					struktogramm.getFirst().delete(true);
					decList = DecList.findDecList(struktogramm);
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("NT$0",24, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // strukgram ::= STARTSTRUK header body ENDSTRUK 
            {
              Object RESULT =null;
		
					struktogramm.recalculate();
				
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("strukgram",1, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-3)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // programs ::= programs strukgram 
            {
              Object RESULT =null;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("programs",0, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= programs EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)).value;
		RESULT = start_val;
              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.elementAt(CUP$LoadParser$top-1)), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$LoadParser$parser.done_parsing();
          return CUP$LoadParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // programs ::= strukgram 
            {
              Object RESULT =null;

              CUP$LoadParser$result = parser.getSymbolFactory().newSymbol("programs",0, ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$LoadParser$stack.peek()), RESULT);
            }
          return CUP$LoadParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

